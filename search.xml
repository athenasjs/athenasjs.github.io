<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/21/hello-world/"/>
      <url>/2019/11/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务管理详解</title>
      <link href="/2019/11/13/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/13/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="事务概念回顾"><a href="#事务概念回顾" class="headerlink" title="事务概念回顾"></a>事务概念回顾</h3><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。对局部数据库事务来说，一个事务处理的操作单元往往对应着一系列的数据库操作，数据库产品对这些数据库的SQL操作已经提供了原子性的支持，对SQL操作而言，它的操作结果有两种：一种是提交成功，数据库操作成功;另一种是回滚，数据库操作不成功，恢复到操作以前的状态。</p><h4 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h4><ol><li>原子性：事务是最小的执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性：执行事务前后，数据保持一致；</li><li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间是独立的。</li><li>持久性：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="Spring事务管理接口介绍"><a href="#Spring事务管理接口介绍" class="headerlink" title="Spring事务管理接口介绍"></a>Spring事务管理接口介绍</h3><h4 id="Spring事务管理接口："><a href="#Spring事务管理接口：" class="headerlink" title="Spring事务管理接口："></a>Spring事务管理接口：</h4><ul><li>PlatformTransactionManager: 事务管理器</li><li>TransactionDefinition: 事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）</li><li>TransactionStatus: 事务运行状态<br>所谓事务管理，其实就是按照给定的事务规则来执行提交或者回滚。<h4 id="PlatformTransactionManager接口介绍"><a href="#PlatformTransactionManager接口介绍" class="headerlink" title="PlatformTransactionManager接口介绍"></a>PlatformTransactionManager接口介绍</h4>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。通过PlatformTransactionManager这个接口,Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。<br>PlatformTransactionManager接口代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>Spring根据不同的持久层框架所对应的接口实现类几个比较常见的如下图所示：<center> <img src="/images/1637b21877cf626d.jpg" width = 60% height = 60% /></center>比如我们在使用JDBC或Mybatis进行数据持久化操作时，我们的xml配置通常如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TransactionDefinition接口介绍"><a href="#TransactionDefinition接口介绍" class="headerlink" title="TransactionDefinition接口介绍"></a>TransactionDefinition接口介绍</h4><p>事务管理器接口PlatformTransactionManager通过getTransaction方法来得到一个事务，这个方法里面的参数就是TransactionDefinition，这个类就定义了一些基本的事务属性。  </p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上，包含了5个方面。</p><center> <img src="/images/1637b43a47916b2d.jpg" width = 60% height = 60% /></center>TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="comment">//返回事务的名字</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">// 返回是否优化为只读事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 事务的隔离级别 （定义了一个事务可能受其他并发事务影响的程度）</p><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作），并发虽然是必须的，但是会导致以下问题。</p><ul><li>脏读  当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据还没有提交，那么另外一个事务读取到的是脏数据，所做的操作可能是不正确的。</li><li>丢失修改（Lost to modify） 指的是在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就会丢失，因此称为丢失修改。<br>例如：事务1读取表中数据A=20,事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li><li>不可重复读： 指的是在一个事务内多次读取同一数据，在这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务的两次读取期间，由于第二个事务的修改导致第一个事务读取的数据不一致，这就发生了在一个事务内两次读取数据不一致的情况，因此成为不可重复读。</li><li>幻读：与不可重复读类似，它发生在一个事务(T1)读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中，第一个事务T1就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以成为幻读。<h4 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别"></a>不可重复读和幻读区别</h4>不可重复读的重点是修改，幻读的重点在于新增或者删除。<br>例1（同样的条件，你读取过的数据，再次读取出来发现值不一样了）：事务1中的A读取自己的工资为1000的操作还没完成，事务2中的B修改了A的工资为2000，导致A再度自己的工资为2000，这就是不可重复读。<br>例2（同样的条件，第一次和第二次读取出来的记录数不一样）：假设工资表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入一条，事务1再次读取时查到的记录就多了一条导致幻读。<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4>TransactionDefinition接口中定义了五个表示隔离级别的常量:</li><li>TransactionDefinition.ISOLATION_DEFAULT 使用后端数据库默认的隔离级别，Mysql默认采用REPEATABLE_READ，Oracle采用READ_COMMITTED</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能导致脏读、不可重复读和幻读</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以避免脏读，但是幻读或不可重复读仍然有可能发生</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果一致，除非数据被本身事务自己修改，可以避免脏读和不可重复读，但是幻读还是会出现。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间完全不可能产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。但是严重影响程序性能。<br>(2) 事务传播行为 （解决业务层方法之间相互调用的事务问题）<br>当事务方法被另一个事务方法调用时，必须指定事务该如何传播，例如：方法有可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。<h5 id="支持当前事务的情况"><a href="#支持当前事务的情况" class="headerlink" title="支持当前事务的情况"></a>支持当前事务的情况</h5></li><li>TransactionDefinition.PROPAGATION_REQUIRED 如果存在当前事务，则加入该事务，如果当前没有事务，则创建一个新事务</li><li>TransactionDefinition.PROPAGATION_SUPPORTS 如果存在当前事务，则加入该事务；否则以非事务的方式继续运行</li><li>TransactionDefinition.PROPAGATION_MANDATORY 如果存在当前事务，则加入该事务；如果没有当前事务，则抛出异常<h5 id="不支持当前事务的情况"><a href="#不支持当前事务的情况" class="headerlink" title="不支持当前事务的情况"></a>不支持当前事务的情况</h5></li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则挂起当前事务</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起</li><li>TransactionDefinition.PROPAGATION_NEVER  以非事务方式运行，如果当前存在事务，则抛出异常。<h5 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h5></li><li>TransactionDefinition.PROPAGATION_NESTED 如果当前存在事务，则创建一个嵌套事务来运行，如果当前没有事务，则等价于TransactionDefinition.PROPAGATION_REQUIRED  </li></ul><p>前面的六种事务传播行为是Spring 从EJB中引入的，它们共享相同的概念，而NESTED是Spring特有的，内嵌事务不是一个单独的事务，依赖于外部事务的存在，只有通过外部事务的提交才能引起内部事务的提交，嵌套的事务不能单独提交。如果熟悉JDBC中保存点savepoint的概念，那嵌套事务就很容易理解，嵌套事务就是保存点的一个应用，一个事务中可以包括多个保存点。外部事务的回滚也会导致嵌套事务的回滚。嵌套事务开始执行时，它将取得一个savepoint，如果这个嵌套事务失败 ，我们将回滚到此savepoint。</p><p>(3) 事务超时属性（一个事务允许执行的最长时间）  </p><p>所谓事务超时，就是指的是一个事务允许执行的最长时间，如果超过该时间限制还没有完成，则自动回滚。  </p><p>(4) 事务只读属性 （对事务资源是否执行只读操作）  </p><p>事务的只读属性是指对事务性资源进行只读操作或者读写操作，所谓事务性资源是指那些被事务管理的资源，比如数据源、JMS资源等，如果确定对事务性资源进行只读操作，那么我们可以将事务标志为只读的，提高事务处理的性能。  </p><p>(5) 回滚规则 （定义事务回滚规则）  </p><p>这些规则定义了哪些异常会导致事务回滚而哪些不会，默认情况下事务只有遇到运行期异常才会回滚，而遇到检查性异常时不会回滚，但是可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><h4 id="TransactionStatus接口介绍"><a href="#TransactionStatus接口介绍" class="headerlink" title="TransactionStatus接口介绍"></a>TransactionStatus接口介绍</h4><p>TransactionStatus接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状况<br>PlatformTransactionManager.getTransaction()方法返回一个TransactionStatus对象，可能代表一个新的或已经存在的事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring事务处理底层实现"><a href="#Spring事务处理底层实现" class="headerlink" title="Spring事务处理底层实现"></a>Spring事务处理底层实现</h3><p>Spring事务处理模块是通过AOP功能来实现声明式事务处理的，在代理对象中通过TransactionInterceptor来完成对代理方法的拦截，正是这些AOP的拦截功能，将事务处理的功能编织进来。</p><h4 id="代理类生成"><a href="#代理类生成" class="headerlink" title="代理类生成"></a>代理类生成</h4><p>为类创建代理的入口位于AbstractAutoProxyCreator.postProcessAfterInitialization，getAdvicesAndAdvisorsForBean用于去容器中寻找合适当前bean的Advisor，对于Spring事务来说有唯一的Advisor:BeanFactoryTransactionAttributeSourceAdvisor。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><h5 id="调用链生成"><a href="#调用链生成" class="headerlink" title="调用链生成"></a>调用链生成</h5><p>getInterceptorsAndDynamicInterceptionAdvice方法，原理是遍历所有使用的Advisor，获得其Advice，将其适配为MethodInterceptor，AdvisorAdaptor接口用以支持用户自定义的Advice类型，将自定义类型转换为拦截器。默认adapters含有MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter三种类型，分别支持MethodBeforeAdvice、AfterReturningAdvice和ThrowsAdvice。<br>对于Spring事务管理来说，只有一个拦截器TransactionInterceptor。  </p><h5 id="调用链调用"><a href="#调用链调用" class="headerlink" title="调用链调用"></a>调用链调用</h5><p>ReflectiveMethodInvocation.proceed(),这其实是一个逐个调用拦截器的invoke方法，最终调用原本方法（被代理方法）的过程，事务添加的核心逻辑在TransactionInterceptor的invoke方法，确定事务管理器，在逻辑执行前开启事务，Spring事务的开启实际上是将数据库的自动提交设为false，事务的提交和回滚也是对jdbc相应方法的封装。  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>事务的本质其实是对数据库自动提交的关闭和开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。</p>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 数据库事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP实现原理-2</title>
      <link href="/2019/11/12/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3/"/>
      <url>/2019/11/12/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3/</url>
      
        <content type="html"><![CDATA[<h3 id="创建AOP代理"><a href="#创建AOP代理" class="headerlink" title="创建AOP代理"></a>创建AOP代理</h3><p>AOP的核心逻辑是在AnnotationAwareAspectJAutoProxyCreator类里面实现，先看看这个类的层次关系：</p><center> <img src="/images/20160421184334804.png" width = 60% height = 60% /></center><p>我们可以看到这个类实现了BeanPostProcessor接口，那就意味着这个类在Spring加载实例化前会调用postProcessAfterInitialization方法，对于AOP的逻辑也是由此开始的。</p><h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><p>1) Spring容器启动，每个bean的实例化前都会先经过AbstractAutoProxyCreator类的postProcessorAfterInitialization()方法，接下来是调用wrapIfNecessary()方法，对目标bean进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public Object &lt;strong&gt;postProcessAfterInitialization&lt;/strong&gt;(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 重点实现逻辑的方法getAdvicesAndAdvisorsForBean，这个方法会提取当前系统中的所有增强方法（切面逻辑），将其封装为Advisor对象，然后获取到适合当前bean的增强方法，并对增强方法进行排序，最后返回一个Advisor的数组，Spring AOP在为目标bean获取需要进行代理的切面逻辑的时候最终得到的是Advisor，这里Advice表示的是每个切面逻辑中使用的@Before、@After、@Around等需要织入的代理方法，因为每个代理方法都表示一个Advice，并且每个代理方法最终都会生成一个Advisor，Advice表示需要织入的切面逻辑，而Advisor表示将切面逻辑进行封装之后的织入者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = &lt;strong&gt;getAdvicesAndAdvisorsForBean&lt;/strong&gt;(bean.getClass(), beanName, null);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 获取到当前bean的所有Advisor后，调用createProxy方法创建代理，先创建代理工厂proxyFactory，然后获取当前bean的增强器Advisor，把当前获取到的增强器添加到代理工厂proxyFactory，然后设置当前的代理工厂的目标对象为当前bean，最后根据配置创建JDK的动态代理工厂，或者CGLIB的动态代理工厂，创建代理对象。对于不同的AopProxy对象的生成，最终由Spring封装的JdkDynamicAopProxy和CglibProxyFactory类来完成。</p><h3 id="AOP动态代理执行"><a href="#AOP动态代理执行" class="headerlink" title="AOP动态代理执行"></a>AOP动态代理执行</h3><p>关于AOP的动态代理执行，有两种主要的方式JDK动态代理和CGLIB动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CglibProxyFactory.createCglibProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据用户的配置（是否配置了proxyTargetClass属性为true）以及目标bean是否实现接口，选择创建的代理类型，下面根据JDK的动态代理来说明AOP的执行，先呈现JdkDynamicAopProxy的核心代码invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throwsThrowable </span>&#123;</span><br><span class="line">       MethodInvocation invocation = <span class="keyword">null</span>;</span><br><span class="line">       Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">       TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">       Class targetClass = <span class="keyword">null</span>;</span><br><span class="line">       Object target = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//eqauls()方法，具目标对象未实现此方法</span></span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123;</span><br><span class="line">                <span class="keyword">return</span> (equals(args[<span class="number">0</span>])? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//hashCode()方法，具目标对象未实现此方法</span></span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123;</span><br><span class="line">                <span class="keyword">return</span> newInteger(hashCode());</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span></span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface()</span><br><span class="line">                    &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">// Service invocations onProxyConfig with the proxy config...</span></span><br><span class="line">                <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised,method, args);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           Object retVal = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                <span class="comment">// Make invocation available ifnecessary.</span></span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//获得目标对象的类</span></span><br><span class="line">           target = targetSource.getTarget();</span><br><span class="line">           <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//获取可以应用到此方法上的Interceptor列表</span></span><br><span class="line">           List chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span></span><br><span class="line">           <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//创建MethodInvocation</span></span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy)</span><br><span class="line">                    &amp;&amp;!RawTargetAccess<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">                <span class="comment">// Special case: it returned"this" and the return type of the method</span></span><br><span class="line">                <span class="comment">// is type-compatible. Notethat we can't help if the target sets</span></span><br><span class="line">                <span class="comment">// a reference to itself inanother returned object.</span></span><br><span class="line">                retVal = proxy;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> retVal;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                <span class="comment">// Must have come fromTargetSource.</span></span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个invoke方法是作为Proxy对象进行拦截的回调入口出现的，在这个方法里获取目标对象以及拦截器链，判断拦截器链是否为空，如果为空则直接调用切点方法，否则创建ReflectiveMethodInvocation类，完成对AOP功能实现的封装，在这个invoke方法中包含了一个完整的拦截器链对目标对象的拦截过程，逐个运行拦截器链里的拦截增强，直到最后对目标对象方法的运行等。对拦截器链的调用是在ReflectiveMethodInvocation中通过proceed方法实现的，在该方法中会逐个运行拦截器的拦截方法，在运行方法之前会对代理方法完成一个匹配判断，决定拦截器是否满足切面增强的要求，如果已经运行到拦截器链的末尾，那么就会直接调用目标对象的实现方法，否则沿着拦截器链继续进行，得到下一个拦截器，通过这个拦截器进行matches判断是否适用于横切增强的场合，如果是，从拦截器中得到通知器，启动invoke()方法进行切面增强，在这个过程结束以后会迭代调用proceed方法，知道拦截器链中所有的拦截器都完成以上的拦截过程为止。复杂的代理终于起到作用了。</p><h3 id="拦截器链的获取"><a href="#拦截器链的获取" class="headerlink" title="拦截器链的获取"></a>拦截器链的获取</h3><p>取得拦截器链的工作由AdvisorChainFactory完成，是一个生成通知器链的工厂，从提供的配置实例config中获取advisor列表，遍历处理这些advisor判断是否能应用到目标类或者目标方法上，将满足条件的Advisor通过适配器AdvisorAdaptor适配成拦截器Interceptor，将能够应用到连接点或者目标类的Advisor全部转化成MethodInterceptor，以MethodBeforeAdviceAdapter为例，实现AdvisorAdaptor接口两个方法：一是supportAdvice，对advice的类型做判断，另一个是getInterceptor接口方法的实现，把advice通知从Advisor中取出，然后创建一个MethodBeforeAdviceInterceptor对象，把取得的advice通知包装起来然后返回。Spring AOP为了实现advice的织入，设计了特定的拦截器对这些功能进行了封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,</span></span><br><span class="line"><span class="comment">    * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断</span></span><br><span class="line"><span class="comment">    * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">publicList <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Advised config, Methodmethod, Class targetClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// This is somewhat tricky... we have to process introductions first,</span></span><br><span class="line">       <span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">       List interceptorList = <span class="keyword">new</span> ArrayList(config.getAdvisors().length);</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//查看是否包含IntroductionAdvisor</span></span><br><span class="line">       <span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config,targetClass);</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor</span></span><br><span class="line">       AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"> </span><br><span class="line">       Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;advisors.length; i++) &#123;</span><br><span class="line">           Advisor advisor = advisors[i];</span><br><span class="line">           <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">                <span class="comment">// Add it conditionally.</span></span><br><span class="line">                PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span>(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span> 这个地方这两个方法的位置可以互换下</span></span><br><span class="line">                    <span class="comment">//将Advisor转化成Interceptor</span></span><br><span class="line">                    MethodInterceptor[]interceptors = registry.getInterceptors(advisor);</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//检查当前advisor的pointcut是否可以匹配当前方法</span></span><br><span class="line">                    MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(mm.isRuntime()) &#123;</span><br><span class="line">                            <span class="comment">// Creating a newobject instance in the getInterceptors() method</span></span><br><span class="line">                            <span class="comment">// isn't a problemas we normally cache created chains.</span></span><br><span class="line">                            <span class="keyword">for</span> (intj = <span class="number">0</span>; j &lt; interceptors.length; j++) &#123;</span><br><span class="line">                               interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptors[j],mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor)&#123;</span><br><span class="line">                IntroductionAdvisor ia =(IntroductionAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span>(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors= registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Interceptor[] interceptors =registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-CGLIB动态代理实现"><a href="#Spring-CGLIB动态代理实现" class="headerlink" title="Spring CGLIB动态代理实现"></a>Spring CGLIB动态代理实现</h4><p>这两个代理的实现方式都差不多，都是创建方法调用链，不同的是jdk的动态代理创建的是ReflectiveMethodInvocation，而CGLIB 创建的是CglibMethodInvocation.</p>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP之AspectJ</title>
      <link href="/2019/11/12/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2/"/>
      <url>/2019/11/12/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2/</url>
      
        <content type="html"><![CDATA[<h3 id="AspectJ的由来"><a href="#AspectJ的由来" class="headerlink" title="@AspectJ的由来"></a>@AspectJ的由来</h3><p>AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译器进行），让java代码具有AspectJ的AOP功能，需要特殊的编译器，可以这样说AspectJ是目前实现AOP框架中最成熟、功能最丰富的语言，而且AspectJ与java程序完全兼容，几乎是无缝关联。其实AspectJ就是一门单独的语言，需要专门的编译器ajc编译器，Spring AOP与AspectJ的目的一致都是为了统一处理横切业务，但与AspectJ不同的是，Spring AOP并不尝试提供完整的AOP功能，更注重的是与Spring IOC容器的结合，并结合该优势来解决横切业务的问题，Spring回避了AspectJ在AOP的实现方式上依赖于特殊的编译器的问题，采用动态代理技术来构建Spring AOP的内部机制，即动态织入，这是与静态织入（AspectJ）最根本的区别。在AspectJ1.5后引入@AspectJ形式的注解风格开发，Spring只是试用了与AspectJ5一样的注解，但是仍然没有使用AspectJ的编译器，底层仍然是动态代理技术的实现，因此并不依赖于AspectJ的编译器。  </p><h3 id="Spring-AOP-AspectJ注解"><a href="#Spring-AOP-AspectJ注解" class="headerlink" title="Spring AOP- AspectJ注解"></a>Spring AOP- AspectJ注解</h3><p>之前的Spring AOP并没有使用@AspectJ这一套注解和aop:config这一套XML解决方案，而是开发者自己定义一些类实现一些接口，后来Spring把AspectJ整合进了Spring中，开启了aop命名空间。<br>AOP的基本概念：</p><ul><li>切点： 定位到具体方法的一个表达式</li><li>切面： 切点+ 通知</li><li>建言（增强）:定位到方法之后做什么事情<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3>maven依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    //下面这两个aspectj的依赖是为了引入AspectJ的注解</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">//Spring AOP底层会使用CGLib来做动态代理</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>实体类:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"在汪汪叫!..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>切面类:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明自己是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//@Before是增强中的方位</span></span><br><span class="line">     <span class="comment">// @Before括号中的就是切入点了</span></span><br><span class="line">     <span class="comment">//before()就是传说的增强(建言):说白了，就是要干啥事.</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.zdy..*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这个类是重点，先用@AspectJ声明自己是切面类，然后before()为增强，@Before(方位)+切入点可以具体定位到具体某个类的某个方法的方位。<br>Spring配置文件:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//开启AspectJ功能.</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.zdy.Dog"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义aspect类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.zdy.MyAspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>然后Main方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac =<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Dog dog =(Dog) ac.getBean(<span class="string">"dog"</span>);</span><br><span class="line">System.out.println(dog.getClass());</span><br><span class="line">dog.say();</span><br></pre></td></tr></table></figure>说白了就是把切面类丢到容器，开启一个AspectJ的功能，Spring AOP就会根据切面类中的@Before+切入点定位好具体的类的某个方法，然后把增强的方法切入进去。<br>Spring AOP支持的几种类似于@Before的AspectJ注解：</li><li>前置通知@Before 可直接传入切点表达式的值，该通知在目标方法执行前执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(...)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>后置通知@AfterReturning 该方法在目标方法执行完成后执行，并可获得最终的返回值returnVal，必须通过returning = “returnVal”注明参数的名称而且必须与通知函数的参数名称相同。请注意，在任何通知中这些参数都是可选的，需要使用时直接填写即可，不需要使用时，可以完成不用声明出来。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(...)"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知...returnVal+"</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>异常通知@AfterThrowing 该通知只有在异常时才会被触发，并由throwing来声明一个接收异常信息的变量，同样异常通知也用于Joinpoint参数，需要时加上即可.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(....)"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"出现异常:msg="</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最终通知@After 该通知有点类似于finally代码块，只要应用了无论什么情况下都会执行.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"execution(...)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>环绕通知@Around 环绕通知既可以在目标方法前执行也可在目标方法之后执行，更重要的是环绕通知可以控制目标方法是否指向执行，但即使如此，我们应该尽量以最简单的方式满足需求，在仅需在目标方法前执行时，应该采用前置通知而非环绕通知。案例代码如下第一个参数必须是ProceedingJoinPoint，通过该对象的proceed()方法来执行目标函数，proceed()的返回值就是环绕通知的返回值。同样的，ProceedingJoinPoint对象也是可以获取目标对象的信息,如类名称,方法参数,方法名称等等<pre><code class="java"><span class="meta">@Around</span>(<span class="string">"execution(...)"</span>)<span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>{  System.out.println(<span class="string">"我是环绕通知前...."</span>);  <span class="comment">//执行目标函数</span>  Object obj= (Object) joinPoint.proceed();  System.out.println(<span class="string">"我是环绕通知后...."</span>);  <span class="keyword">return</span> obj;}</code></pre></li></ul><p>```<br>常用的切入点表达式:</p><ul><li>execution(* com.sunjianshu..*(..)) 匹配包下所有类的所有方法</li><li>execution(* com.sunjianshu.Dog.*(..)) 匹配Dog类下的所有方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP基础</title>
      <link href="/2019/11/11/Spring-AOP%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/11/11/Spring-AOP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP即面向切面编程，相比OOP–面向对象编程，由于面向对象中最基本的单位是类，实例，很自然我们会联想到AOP中最基本的单位是切面。<br>Spring中关于AOP的定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向切面--Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计和事务管理）进行内聚性的开发。应用对象只实现它们应该做的--完成业务逻辑，仅此而已，它们并不负责其他的系统级关注点，例如日志或事务支持。</span><br></pre></td></tr></table></figure><p>上面谈到，AOP可以分离系统的业务逻辑和系统服务（日志、安全等），原理是使用了代理模式，但关键是为什么要将这两种分离呢？或者说这样有什么好处？<br>特点：1. 降低模块之间的耦合度 2.使系统容易扩展 3. 更好的代码复用</p><p>在日常的软件开发中，拿日志来说，一个系统软件的开发都是必须进行日志记录的，不然万一系统出现bug，你都不知道是哪里出了问题，举个小栗子，当开发一个登录功能，可能需要在用户登录前后进行权限校验并将校验信息（用户名、密码、请求登录时间、ip地址等）记录在日志文件中，当用户登录进来时，访问某个其他功能时也需要进行合法性校验。想想看，当系统非常庞大，系统中专门进行权限验证的代码是非常多的，而且非常散乱，我们就思考能不能将这些权限校验、日志记录等非业务逻辑功能的部分独立拆开，并且在系统运行时需要的地方（连接点）动态插入运行，不需要的时候就不理，因此AOP是能解决这种问题的思想。</p><p>下图直观展示这个过程：</p><center> <img src="/images/1621e668fb77807c.jpg" width = 60% height = 60% /></center> <h2 id="AOP中的基本概念"><a href="#AOP中的基本概念" class="headerlink" title="AOP中的基本概念"></a>AOP中的基本概念</h2><ul><li>通知（Advice）：切面对于某个连接点所产生的动作<br>通知有5种类型：</li></ul><ol><li>Before 在方法被调用之前调用，不能阻止连接点的执行。</li><li>After 在方法完成后调用通知，无论方法是否执行成功</li><li>After-returning 在方法成功执行之后调用通知</li><li>After-throwing 在方法抛出异常后调用通知</li><li>Around 环绕通知，在被通知的方法调用之前和调用之后执行自定义的行为，类似于Web中Servlet规范中的Filter中doFilter方法，可以在方法的调用前后完成自定义行为，也可以选择不执行。</li></ol><ul><li>切点 （Pointcut）<br>切点在Spring AOP中确实是对应系统中的方法，但是这个方法是定义在切面中的方法，一般和通知一起使用，一起组成了切面。切入点是匹配连接点的断言，在AOP中通知和一个切入点表达式关联。</li><li>连接点(Join point)<br>比如：方法调用、方法执行、字段设置/获取、异常处理执行、类初始化、甚至是for循环中的某个点，理论上程序执行过程中的任何时间点都可以作为连接点，但是Spring AOP目前仅仅支持方法执行（method execution），也可以这样理解，连接点就是准备在系统中执行切点和切入通知的地方（一般是一个方法、一个字段）。程序执行过程中的某一行为。</li><li>切面（Aspect）<br>切面是切点和通知的集合，一般单独作为一个类，通知和切点共同定义了关于切面的全部内容，定义了在何时何处完成功能。</li><li>引入 （Introduction）<br>允许我们向现有的类添加新的方法或者属性</li><li>织入（Weaving）<br>组装切面来创建一个被通知对象，这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li><li>目标对象(Target Object) 被一个或多个切面所通知的对象  </li></ul><h2 id="Spring中对AOP的支持"><a href="#Spring中对AOP的支持" class="headerlink" title="Spring中对AOP的支持"></a>Spring中对AOP的支持</h2><p>首先AOP思想的实现一般基于代理模式，在JAVA中一般采用JDK动态代理方法，但是JDK的动态代理只能代理接口，如果要代理类那就不行了，因此Spring AOP会做切换，因为Spring AOP同时支持CGLIB、ASPECTJ、JDK动态代理，当真实目标类有实现接口时，Spring AOP会默认采用JDK动态代理，否则采用CGLIB动态代理。<br>核心逻辑：如果配置文件中指定了proxy-target-class为true，则使用CGlib方式进行代理，如果没有指定或者为false，那么会先检测被代理类是否实现自己的接口，如果实现了，那么就采用JDK动态代理的方式。</p><ul><li>如果目标类实现了接口，Spring AOP会采用JDK动态代理来生成AOP代理类；</li><li>如果目标类没有实现接口，Spring AOP会采用CGLIB生成AOP代理类，这个选择过程完全对开发者透明，开发者无需关心。</li></ul><h2 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h2><ul><li>定义主题接口，这些接口方法可以成为我们的连接点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wokao666.club.aop.spring01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登陆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义实现类，这是代理模式中真正的被代理人<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wokao666.club.aop.spring02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wokao666.club.aop.spring01.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">"借书中..."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">"下载中..."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义切面 切面中有切点和通知<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wokao666.club.aop.spring01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionVerification</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 权限校验</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> args 登陆参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">canLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做一些登陆校验</span></span><br><span class="line">System.err.println(<span class="string">"我正在校验啦！！！！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验之后做一些处理（无论是否成功都做处理）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args 权限校验参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做一些后置处理</span></span><br><span class="line">System.err.println(<span class="string">"我正在处理啦！！！！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>再看看SpringAOP.xml文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"SubjectImpl1"</span> <span class="attr">class</span>=<span class="string">"wokao666.club.aop.spring02.SubjectImpl"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"SubjectImpl2"</span> <span class="attr">class</span>=<span class="string">"wokao666.club.aop.spring02.SubjectImpl"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"PermissionVerification"</span> <span class="attr">class</span>=<span class="string">"wokao666.club.aop.spring01.PermissionVerification"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这是定义一个切面，切面是切点和通知的集合--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"do"</span> <span class="attr">ref</span>=<span class="string">"PermissionVerification"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 定义切点 ，后面是expression语言，表示包括该接口中定义的所有方法都会被执行--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point"</span> <span class="attr">expression</span>=<span class="string">"execution(* wokao666.club.aop.spring01.Subject.*(..))"</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 定义通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"canLogin"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"saveMessage"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>最后看看测试类和结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wokao666.club.aop.spring01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext ctx = </span><br><span class="line">      <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"SpringAOP.xml"</span>);</span><br><span class="line">  </span><br><span class="line">Subject subject1 = (Subject)ctx.getBean(<span class="string">"SubjectImpl1"</span>);</span><br><span class="line">Subject subject2 = (Subject)ctx.getBean(<span class="string">"SubjectImpl2"</span>);</span><br><span class="line"></span><br><span class="line">subject1.login();</span><br><span class="line">subject1.download();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">"=================="</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subject1.login();</span><br><span class="line">subject1.download();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我正在校验啦！！！！</span><br><span class="line">借书中...</span><br><span class="line">我正在处理啦！！！！</span><br><span class="line">我正在校验啦！！！！</span><br><span class="line">下载中...</span><br><span class="line">我正在处理啦！！！！</span><br><span class="line">==================</span><br><span class="line">我正在校验啦！！！！</span><br><span class="line">借书中...</span><br><span class="line">我正在处理啦！！！！</span><br><span class="line">我正在校验啦！！！！</span><br><span class="line">下载中...</span><br><span class="line">我正在处理啦！！！！</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP实现原理(1)</title>
      <link href="/2019/11/11/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1/"/>
      <url>/2019/11/11/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h2><p>自己整理了一下AOP实现的几种方式，同时把代理模式相关知识也稍微整理一下。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式的UML类图如下：</p><center> <img src="/images/756310-20160924153802543-1643119235.jpg" width = 60% height = 60% /></center>  可以看到还是很简单的，代理类实现类了被代理类的接口，同时与被代理类是组合关系。下面看一下代理模式的实现。<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor;</span><br><span class="line">    <span class="keyword">private</span> String before;</span><br><span class="line">    <span class="keyword">private</span> String after;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Actor actor, String before, String after)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">        <span class="keyword">this</span>.before = before;</span><br><span class="line">        <span class="keyword">this</span>.after = after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//before speak</span></span><br><span class="line">        System.out.println(<span class="string">"Before actor speak, Agent say: "</span> + before);</span><br><span class="line">        <span class="comment">//real speak</span></span><br><span class="line">        <span class="keyword">this</span>.actor.speak();</span><br><span class="line">        <span class="comment">//after speak</span></span><br><span class="line">        System.out.println(<span class="string">"After actor speak, Agent say: "</span> + after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Actor actor = <span class="keyword">new</span> Actor(<span class="string">"I am a famous actor!"</span>);</span><br><span class="line">        Agent agent = <span class="keyword">new</span> Agent(actor, <span class="string">"Hello I am an agent."</span>, <span class="string">"That's all!"</span>);</span><br><span class="line">        agent.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><center> <img src="/images/756310-20160924161444074-1045394614.jpg" width = 60% height = 60% /></center><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK自带方法"><a href="#JDK自带方法" class="headerlink" title="JDK自带方法"></a>JDK自带方法</h4><p>首先介绍一下最核心的一个接口和一个方法:<br>首先是java.lang.reflect包里的InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对于被代理的类的操作都会由该接口中的invoke方法实现，其中的参数含义分别是：</p><ul><li>proxy: 代理的类的实例</li><li>method: 调用被代理类的方法</li><li>args: 该方法需要的参数</li></ul><p>使用方法首先需要实现该接口，并且可以在invoke方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法前后去做一些额外的事情增强功能，从而实现动态代理，下面的例子会写到。<br>另外一个很重要的静态方法是java.lang.reflect包中的Proxy类中的newProxyInstance方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>其中参数含义如下：</p><ul><li>loader: 被代理的类的类加载器</li><li>interfaces: 被代理类的接口数组</li><li>invocationHandler: 就是刚刚介绍的调用处理器类的对象实例</li></ul><p>该方法会返回一个被修改过的代理类的实例，从而可以自由调用该实例的方法，下面是一个实际例子：<br>Fruit接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple实现Fruit接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;show method is invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类Agent.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现InvocationHandler接口，并且可以初始化被代理类的对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object proxy;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//自定义invoke方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;&gt;before invoking"</span>);</span><br><span class="line">            <span class="comment">//真正调用方法的地方</span></span><br><span class="line">            Object ret = method.invoke(<span class="keyword">this</span>.proxy, args);</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;&gt;after invoking"</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个被修改过的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">agent</span><span class="params">(Class interfaceClazz, Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(interfaceClazz.getClassLoader(), <span class="keyword">new</span> Class[]&#123;interfaceClazz&#125;,</span><br><span class="line">                <span class="keyword">new</span> MyHandler(proxy));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//注意一定要返回接口，不能返回实现类否则会报错</span></span><br><span class="line">        Fruit fruit = (Fruit) DynamicAgent.agent(Fruit<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Apple</span>())</span>;</span><br><span class="line">        fruit.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><center> <img src="/images/756310-20161224235824807-1026162849.jpg" width = 60% height = 60% /></center><p>可以看到对于不同的实现类来说，可以用同一个动态代理类来进行代理，实现了一次编写到处代理的效果，但是这种方法有个缺点就是被代理类一定要实现接口，这很大程度上限制了本方法的使用场景。下面还有一个使用CGLIB增强库的方法。</p><h4 id="CGLIB库的方法"><a href="#CGLIB库的方法" class="headerlink" title="CGLIB库的方法"></a>CGLIB库的方法</h4><p>CGLIB是一个字节码增强库，为AOP等提供了底层支持。下面看看它怎么实现动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibAgent</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.proxy.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;before invoking"</span>);</span><br><span class="line">        <span class="comment">//真正调用</span></span><br><span class="line">        Object ret = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;after invoking"</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGlibAgent cGlibAgent = <span class="keyword">new</span> CGlibAgent();</span><br><span class="line">        Apple apple = (Apple) cGlibAgent.getInstance(<span class="keyword">new</span> Apple());</span><br><span class="line">        apple.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。CGLIB是一个强大的高质量高性能的Code生成类库，可以在运行期扩展Java类与实现接口，代理为控制对目标对象的访问提供了一种途径，当访问对象时引入了间接的一层，JDK从1.3开始就引入了动态代理，限制就是使用动态代理的目标类必须实现一个或多个接口。CGLIB是一个强大的高性能代码生成包，广泛被许多AOP框架使用如Spring AOP，它们提供方法的拦截，CGLIB包的底层是通过使用一个小而块的字节码处理框架ASM，来转换字节码并生成新的类。</p><h3 id="代理模式总结"><a href="#代理模式总结" class="headerlink" title="代理模式总结"></a>代理模式总结</h3><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有相同的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。<br>按照代理的创建时期，代理类可以分为两种：</p><ul><li>静态代理：由程序员或者特定工具自动生成源代码，再对其编译，在程序运行前，代理类的.class文件就已经存在。静态代理每一个代理类只能为一个接口服务，程序开发中必然会产生过多的代理，而且所有的代理操作除了调用的方法不一样，其他操作都一样，大量重复代码。解决这一问题最好做法就是通过一个代理类完成全部的代理功能。</li><li>动态代理：在程序运行时，运用反射机制动态创建而成</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(1)</title>
      <link href="/2019/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/"/>
      <url>/2019/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI与TCP-IP各层的结构与功能，都有哪些协议"><a href="#OSI与TCP-IP各层的结构与功能，都有哪些协议" class="headerlink" title="OSI与TCP/IP各层的结构与功能，都有哪些协议"></a>OSI与TCP/IP各层的结构与功能，都有哪些协议</h2><h3 id="OSI开放式互联参考模型"><a href="#OSI开放式互联参考模型" class="headerlink" title="OSI开放式互联参考模型"></a><strong>OSI开放式互联参考模型</strong></h3><p>当前市面上存在四层、五层、七层协议，而ISO国际标准化组织提出来的OSI七层协议模型是业界提出的概念性框架</p><center> <img src="/images/微信截图_20191107214712.png" width = 60% height = 60% /></center>  <h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h3><p>首先要解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到这些比特流，这便是物理层要做的事情。主要定义物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流，0-1比特流转化为电流强弱来传输，到达目的后再转化为0-1机器码，也就是数模转换、 模数转换，网卡工作在这一层。物理层作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使上面的数据链路层不必考虑网络的具体传输介质是什么。</p><h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h3><p>在传输比特流的过程中会产生错传、传输不完整的可能，因此数据链路层应运而生，定义了如何格式化数据以及控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据传输的可靠性。本层将网络层交下来的IP数据报组装成帧，在两个相邻节点的链路上传送帧。交换机工作在这一层，对帧解码，并根据帧中包含的信息把帧送到正确的接收方。在接收数据时控制信息使得接收端能够知道一个帧从哪个比特开始和到哪个比特结束，就可以从中提取出数据部分，上交给网络层。控制信息还使得接收端能够检测到收到的帧中有差错，如果发现差错，数据链路层就简单地丢弃这个出差错的帧，以避免继续在网络中传送下去浪费网络资源，如果需要改正数据在链路层传输时出现差错，那么就需要采用可靠性传输协议来纠正差错，这种方法会使得链路层的协议复杂一些。</p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><p>随着网络节点的增加，点对点通信时候需要经过多个节点，如何找到目标节点，如果选择最优路径便成为首要需求。此时便有了网络层，主要功能是把网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。路由器属于网络层，连接网络各段。此层的数据成为数据包，本层需要关注的是TCP/IP协议中的IP协议。网络层的任务就是选择合适的网间路由和交换节点，确保数据的及时传送。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组和包进行传送。</p><h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h3><p>随着网络通信需求的进一步扩大，通信过程中需要传输大量数据如海量文件传输等，可能需要很长时间，网络可能中断很多次，此时为了保证数据正确性，需要对发出去的数据进行切分，分割为一个一个的段落segment，那么其中一个段落丢失了怎么办，要不要重传，每个段落要按照顺序到达么，这个便是传输层需要考虑的问题。负责主机之间的数据传输，解决传输质量的问题，传输协议同时进行流量控制，或者根据接收方接收数据的快慢程度规定适当的发送速率，除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，（数据片序列号 排序） TCP/UDP协议 运输层负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p><h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h3><p>经过下面四层，数据已经可以正确发送到另外一台机器了，但是不能让用户每一次都用TCP打包数据，然后用IP寻址，需要建立自动收发包和寻址的机制。会话层负责不同机器上的用户之间建立及管理会话。</p><h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h3><p>如果要用linux给windows发包，两个系统语法不一致，于是需要表示层帮我们解决不同通信系统之间的语法问题，负责信息的语法语意以及它们的关联，如加密解密、转换翻译、压缩解压缩。</p><h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h3><p>规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头里必须记录消息的长度等一系列信息，以方便接收方能正确解析发送方的数据，旨在更方便的利用从网络中接收到的数据。至于数据的传递，没有该层也可以用TCP实现，不过传来传去都是一些01的字节数组而已。该层需要关注的是与之相对应的TCP/IP协议中的HTTP协议。应用层协议定义的是应用进程之间的通信和交互规则，对于不同的网络应用需要不同的应用层协议。如域名系统DNS、支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等，应用层交互的数据单元称为报文。</p><h3 id="数据的解析过程"><a href="#数据的解析过程" class="headerlink" title="数据的解析过程"></a>数据的解析过程</h3><p>从应用层开始，都会对要传输的数据头部进行处理，先自上而下，后自下而上处理数据头部，加上本层的一些信息，最终由物理层将数据解析成比特流在网络中传输，数据传递到目标地址，自底而上将先前加上的头部给解析分离出来。</p><center> <img src="/images/微信截图_20191107211332.png" width = 60% height = 60% /></center>  <h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>OSI参考模型定义了开放系统的层次结构，层次之间的相互关系以及各层所包括的可能的任务，作为一个理论框架协调各层所提供的服务，但是并没有提供一个可实现的方法，而是描述了一些概念，即OSI参考模型并不是标准，而是在制定标准时使用的一个概念型框架，事实上的标准是TCP/IP四层架构参考模型，可以理解成是OSI的一种实现。OSI模型注重通信协议必要的功能是什么，而TCP/IP更强调在计算机上实现协议应该开发哪种程序。</p><center> <img src="/images/微信截图_20191107214215.png" width = 60% height = 60% /></center>  <p>TCP/IP泛指网际协议群，HTTP\Telnet等等都是属于该协议群，是互联网的重要组成部分。在数据传输的过程中，和OSI模型一样，TCP/IP的每一层都会对数据附加一个头部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议等，数据发送到目标地址之后再层层解套出来。</p><center> <img src="/images/微信截图_20191107214609.png" width = 60% height = 60% /></center>  ]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-second-blog</title>
      <link href="/2019/11/05/my-second-blog/"/>
      <url>/2019/11/05/my-second-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> tomcat类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-second-blog</title>
      <link href="/2019/11/05/my-third-blog/"/>
      <url>/2019/11/05/my-third-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> tomcat类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2019/11/05/my-first-blog/"/>
      <url>/2019/11/05/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
