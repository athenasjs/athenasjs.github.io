<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring AOP实现原理(1)</title>
      <link href="/2019/11/11/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1/"/>
      <url>/2019/11/11/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h2><p>自己整理了一下AOP实现的几种方式，同时把代理模式相关知识也稍微整理一下。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式的UML类图如下：</p><center> <img src="/images/756310-20160924153802543-1643119235.jpg" width = 60% height = 60% /></center>  可以看到还是很简单的，代理类实现类了被代理类的接口，同时与被代理类是组合关系。下面看一下代理模式的实现。<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor;</span><br><span class="line">    <span class="keyword">private</span> String before;</span><br><span class="line">    <span class="keyword">private</span> String after;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Actor actor, String before, String after)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">        <span class="keyword">this</span>.before = before;</span><br><span class="line">        <span class="keyword">this</span>.after = after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//before speak</span></span><br><span class="line">        System.out.println(<span class="string">"Before actor speak, Agent say: "</span> + before);</span><br><span class="line">        <span class="comment">//real speak</span></span><br><span class="line">        <span class="keyword">this</span>.actor.speak();</span><br><span class="line">        <span class="comment">//after speak</span></span><br><span class="line">        System.out.println(<span class="string">"After actor speak, Agent say: "</span> + after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Actor actor = <span class="keyword">new</span> Actor(<span class="string">"I am a famous actor!"</span>);</span><br><span class="line">        Agent agent = <span class="keyword">new</span> Agent(actor, <span class="string">"Hello I am an agent."</span>, <span class="string">"That's all!"</span>);</span><br><span class="line">        agent.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><center> <img src="/images/756310-20160924161444074-1045394614.jpg" width = 60% height = 60% /></center><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK自带方法"><a href="#JDK自带方法" class="headerlink" title="JDK自带方法"></a>JDK自带方法</h4><p>首先介绍一下最核心的一个接口和一个方法:<br>首先是java.lang.reflect包里的InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对于被代理的类的操作都会由该接口中的invoke方法实现，其中的参数含义分别是：</p><ul><li>proxy: 代理的类的实例</li><li>method: 调用被代理类的方法</li><li>args: 该方法需要的参数</li></ul><p>使用方法首先需要实现该接口，并且可以在invoke方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法前后去做一些额外的事情增强功能，从而实现动态代理，下面的例子会写到。<br>另外一个很重要的静态方法是java.lang.reflect包中的Proxy类中的newProxyInstance方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>其中参数含义如下：</p><ul><li>loader: 被代理的类的类加载器</li><li>interfaces: 被代理类的接口数组</li><li>invocationHandler: 就是刚刚介绍的调用处理器类的对象实例</li></ul><p>该方法会返回一个被修改过的代理类的实例，从而可以自由调用该实例的方法，下面是一个实际例子：<br>Fruit接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple实现Fruit接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;show method is invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类Agent.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现InvocationHandler接口，并且可以初始化被代理类的对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object proxy;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//自定义invoke方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;&gt;before invoking"</span>);</span><br><span class="line">            <span class="comment">//真正调用方法的地方</span></span><br><span class="line">            Object ret = method.invoke(<span class="keyword">this</span>.proxy, args);</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;&gt;after invoking"</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个被修改过的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">agent</span><span class="params">(Class interfaceClazz, Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(interfaceClazz.getClassLoader(), <span class="keyword">new</span> Class[]&#123;interfaceClazz&#125;,</span><br><span class="line">                <span class="keyword">new</span> MyHandler(proxy));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//注意一定要返回接口，不能返回实现类否则会报错</span></span><br><span class="line">        Fruit fruit = (Fruit) DynamicAgent.agent(Fruit<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Apple</span>())</span>;</span><br><span class="line">        fruit.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><center> <img src="/images/756310-20161224235824807-1026162849.jpg" width = 60% height = 60% /></center><p>可以看到对于不同的实现类来说，可以用同一个动态代理类来进行代理，实现了一次编写到处代理的效果，但是这种方法有个缺点就是被代理类一定要实现接口，这很大程度上限制了本方法的使用场景。下面还有一个使用CGLIB增强库的方法。</p><h4 id="CGLIB库的方法"><a href="#CGLIB库的方法" class="headerlink" title="CGLIB库的方法"></a>CGLIB库的方法</h4><p>CGLIB是一个字节码增强库，为AOP等提供了底层支持。下面看看它怎么实现动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibAgent</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.proxy.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;before invoking"</span>);</span><br><span class="line">        <span class="comment">//真正调用</span></span><br><span class="line">        Object ret = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;after invoking"</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGlibAgent cGlibAgent = <span class="keyword">new</span> CGlibAgent();</span><br><span class="line">        Apple apple = (Apple) cGlibAgent.getInstance(<span class="keyword">new</span> Apple());</span><br><span class="line">        apple.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>]]></content>
      
      
      <categories>
          
          <category> Spring读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(1)</title>
      <link href="/2019/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/"/>
      <url>/2019/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI与TCP-IP各层的结构与功能，都有哪些协议"><a href="#OSI与TCP-IP各层的结构与功能，都有哪些协议" class="headerlink" title="OSI与TCP/IP各层的结构与功能，都有哪些协议"></a>OSI与TCP/IP各层的结构与功能，都有哪些协议</h2><h3 id="OSI开放式互联参考模型"><a href="#OSI开放式互联参考模型" class="headerlink" title="OSI开放式互联参考模型"></a><strong>OSI开放式互联参考模型</strong></h3><p>当前市面上存在四层、五层、七层协议，而ISO国际标准化组织提出来的OSI七层协议模型是业界提出的概念性框架</p><center> <img src="/images/微信截图_20191107214712.png" width = 60% height = 60% /></center>  <h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h3><p>首先要解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到这些比特流，这便是物理层要做的事情。主要定义物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流，0-1比特流转化为电流强弱来传输，到达目的后再转化为0-1机器码，也就是数模转换、 模数转换，网卡工作在这一层。物理层作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使上面的数据链路层不必考虑网络的具体传输介质是什么。</p><h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h3><p>在传输比特流的过程中会产生错传、传输不完整的可能，因此数据链路层应运而生，定义了如何格式化数据以及控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据传输的可靠性。本层将网络层交下来的IP数据报组装成帧，在两个相邻节点的链路上传送帧。交换机工作在这一层，对帧解码，并根据帧中包含的信息把帧送到正确的接收方。在接收数据时控制信息使得接收端能够知道一个帧从哪个比特开始和到哪个比特结束，就可以从中提取出数据部分，上交给网络层。控制信息还使得接收端能够检测到收到的帧中有差错，如果发现差错，数据链路层就简单地丢弃这个出差错的帧，以避免继续在网络中传送下去浪费网络资源，如果需要改正数据在链路层传输时出现差错，那么就需要采用可靠性传输协议来纠正差错，这种方法会使得链路层的协议复杂一些。</p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><p>随着网络节点的增加，点对点通信时候需要经过多个节点，如何找到目标节点，如果选择最优路径便成为首要需求。此时便有了网络层，主要功能是把网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。路由器属于网络层，连接网络各段。此层的数据成为数据包，本层需要关注的是TCP/IP协议中的IP协议。网络层的任务就是选择合适的网间路由和交换节点，确保数据的及时传送。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组和包进行传送。</p><h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h3><p>随着网络通信需求的进一步扩大，通信过程中需要传输大量数据如海量文件传输等，可能需要很长时间，网络可能中断很多次，此时为了保证数据正确性，需要对发出去的数据进行切分，分割为一个一个的段落segment，那么其中一个段落丢失了怎么办，要不要重传，每个段落要按照顺序到达么，这个便是传输层需要考虑的问题。负责主机之间的数据传输，解决传输质量的问题，传输协议同时进行流量控制，或者根据接收方接收数据的快慢程度规定适当的发送速率，除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，（数据片序列号 排序） TCP/UDP协议 运输层负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p><h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h3><p>经过下面四层，数据已经可以正确发送到另外一台机器了，但是不能让用户每一次都用TCP打包数据，然后用IP寻址，需要建立自动收发包和寻址的机制。会话层负责不同机器上的用户之间建立及管理会话。</p><h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h3><p>如果要用linux给windows发包，两个系统语法不一致，于是需要表示层帮我们解决不同通信系统之间的语法问题，负责信息的语法语意以及它们的关联，如加密解密、转换翻译、压缩解压缩。</p><h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h3><p>规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头里必须记录消息的长度等一系列信息，以方便接收方能正确解析发送方的数据，旨在更方便的利用从网络中接收到的数据。至于数据的传递，没有该层也可以用TCP实现，不过传来传去都是一些01的字节数组而已。该层需要关注的是与之相对应的TCP/IP协议中的HTTP协议。应用层协议定义的是应用进程之间的通信和交互规则，对于不同的网络应用需要不同的应用层协议。如域名系统DNS、支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等，应用层交互的数据单元称为报文。</p><h3 id="数据的解析过程"><a href="#数据的解析过程" class="headerlink" title="数据的解析过程"></a>数据的解析过程</h3><p>从应用层开始，都会对要传输的数据头部进行处理，先自上而下，后自下而上处理数据头部，加上本层的一些信息，最终由物理层将数据解析成比特流在网络中传输，数据传递到目标地址，自底而上将先前加上的头部给解析分离出来。</p><center> <img src="/images/微信截图_20191107211332.png" width = 60% height = 60% /></center>  <h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>OSI参考模型定义了开放系统的层次结构，层次之间的相互关系以及各层所包括的可能的任务，作为一个理论框架协调各层所提供的服务，但是并没有提供一个可实现的方法，而是描述了一些概念，即OSI参考模型并不是标准，而是在制定标准时使用的一个概念型框架，事实上的标准是TCP/IP四层架构参考模型，可以理解成是OSI的一种实现。OSI模型注重通信协议必要的功能是什么，而TCP/IP更强调在计算机上实现协议应该开发哪种程序。</p><center> <img src="/images/微信截图_20191107214215.png" width = 60% height = 60% /></center>  <p>TCP/IP泛指网际协议群，HTTP\Telnet等等都是属于该协议群，是互联网的重要组成部分。在数据传输的过程中，和OSI模型一样，TCP/IP的每一层都会对数据附加一个头部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议等，数据发送到目标地址之后再层层解套出来。</p><center> <img src="/images/微信截图_20191107214609.png" width = 60% height = 60% /></center>  ]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-second-blog</title>
      <link href="/2019/11/05/my-second-blog/"/>
      <url>/2019/11/05/my-second-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> tomcat类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-second-blog</title>
      <link href="/2019/11/05/my-third-blog/"/>
      <url>/2019/11/05/my-third-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> tomcat类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2019/11/05/my-first-blog/"/>
      <url>/2019/11/05/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件</li><li>免费方便</li></ol><a id="more"></a><p>4.数据绝对安全</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/05/hello-world/"/>
      <url>/2019/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
